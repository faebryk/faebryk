# This file is part of the faebryk project
# SPDX-License-Identifier: MIT

"""
"""

import re
import black

template = """
# This file was generated by faebryk netlist exporter
{header}

\"""
{docstring}
\"""
from pathlib import Path
import logging

logger = logging.getLogger("main")


def run_experiment():
    # function imports
    from faebryk.exporters.netlist.kicad.netlist_kicad import from_faebryk_t2_netlist
    from faebryk.exporters.netlist import make_t2_netlist_from_t1
    from faebryk.exporters.netlist.graph import (
        make_graph_from_components,
        make_t1_netlist_from_graph,
    )
    {function_imports}

    # library imports
    from faebryk.library.core import Component
    from faebryk.library.library.parameters import Constant
    from faebryk.library.library.interfaces import Electrical
    from faebryk.library.trait_impl.component import (
        has_defined_footprint,
        has_defined_footprint_pinmap,
        has_defined_type_description,
    )
    from faebryk.library.kicad import (
        has_kicad_manual_footprint,
        has_defined_kicad_ref,
    )
    {library_imports}

    {definitions}

    {connections}

    comps = [
        {comps}
    ]

    t1_ = make_t1_netlist_from_graph(make_graph_from_components(comps))

    netlist = from_faebryk_t2_netlist(make_t2_netlist_from_t1(t1_))

    path = Path("./build/faebryk.net")
    logger.info("Writing Experiment netlist to {{}}".format(path.absolute()))
    path.write_text(netlist)

    from faebryk.exporters.netlist import render_graph

    render_graph(t1_)

# Boilerplate -----------------------------------------------------------------
import sys


def main(argc, argv, argi):
    logging.basicConfig(level=logging.INFO)

    logger.info("Running experiment")
    run_experiment()


if __name__ == "__main__":
    import os
    import sys

    root = os.path.join(os.path.dirname(__file__), "..")
    sys.path.append(root)
    main(len(sys.argv), sys.argv, iter(sys.argv))

"""

comp_template = """
    {ifs}

    {name} = Component()

    {unnamed_if_expr}
    {named_if_expr} 
    {trait_expr}
"""

unnamed_if_template = "{name}.IFs.add_all({unnamed_if_refs})"


def dict_to_str(obj):
    return "{" + ", ".join(f"{k}:{v}" for k, v in obj.items()) + "}"


def str_to_str(obj):
    return f'"{obj}"'


def from_t1_netlist(t1_netlist):
    # t1_netlist = [comps{
    #   name,
    #   real,
    #   properties,
    #   neighbors,
    #   value,
    # }]

    components = t1_netlist
    project = template

    comp_names = {}
    if_names = {}

    def comp_to_faebryk(component):
        def get_comp_name(component):
            if component["name"].startswith("COMP["):
                class_name = re.search(r"\[(.*):.*\]", component["name"]).group(1)
            else:
                class_name = component["name"]

            # TODO sanitize
            if re.match("^[a-zA-Z_]+[a-zA-Z_0-9]*$", class_name) is None:
                assert False, class_name

            ctr = comp_names.get(class_name, 0)
            name = "{type}_{ctr}".format(type=class_name, ctr=ctr)
            comp_names[class_name] = ctr + 1

            return name

        name = get_comp_name(component)

        pinmap = {pin: f"{name}.IFs.P{pin}" for pin in component["neighbors"].keys()}

        named_if_expr = "\n    ".join(
            [f"{pin_name} = Electrical()" for pin_name in pinmap.values()]
        )

        # Traits --------------------------------------------------
        trait_template = "\n    ".join(
            [
                f"{name}" + ".add_trait({trait_name}(",
                "    {trait_args}",
                "))",
            ]
        )

        traits = []
        def add_trait(name, args):
            traits.append(
                trait_template.format(trait_name=name, trait_args=args)
            )


        add_trait("has_defined_footprint_pinmap", dict_to_str(pinmap))

        if component["real"]:
            add_trait("has_defined_type_description", str_to_str(component["value"]))

            add_trait("has_kicad_manual_footprint", 
                str_to_str(component["properties"]["footprint"]),
            )

        trait_expr = "\n    ".join(traits)

        # ---------------------------------------------------------

        comp = comp_template.format(
            ifs="",
            unnamed_if_expr="",
            name=name,
            named_if_expr=named_if_expr,
            trait_expr=trait_expr,
        )

        return name, (comp, pinmap, component)

    named_comps = dict(map(comp_to_faebryk, components))
    name_map = {c["name"]: cname for cname, (_, __, c) in named_comps.items()}

    connections = []
    for cname, (ccode, pinmap, comp) in named_comps.items():
        for pin, neighbors in comp["neighbors"].items():
            for neighbor in neighbors:
                neighborcname = name_map[neighbor["vertex"]["name"]]
                npin = neighbor["pin"]
                connections.append(
                    f"{pinmap[pin]}.connect({named_comps[neighborcname][1][npin]})"
                )

    project = project.format(
        header="",
        docstring="",
        function_imports="",
        library_imports="",
        definitions="\n        ".join([c[0] for c in named_comps.values()]),
        connections="\n    ".join(connections),
        comps=",\n        ".join(named_comps.keys()),
    )

    project = black.format_file_contents(project, fast=False, mode=black.Mode())
    # project = black.format_str(project, mode=black.Mode())

    return project
