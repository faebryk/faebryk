# This file is part of the faebryk project
# SPDX-License-Identifier: MIT

"""
"""

import re
import black
import logging

logger = logging.getLogger("export_faebryk")

template = """
# This file was generated by faebryk netlist exporter
{header}

\"""
{docstring}
\"""
from pathlib import Path
import logging

logger = logging.getLogger("main")


def run_experiment():
    # function imports
    from faebryk.exporters.netlist.kicad.netlist_kicad import from_faebryk_t2_netlist
    from faebryk.exporters.netlist import make_t2_netlist_from_t1
    from faebryk.exporters.netlist.graph import (
        make_graph_from_components,
        make_t1_netlist_from_graph,
    )
    {function_imports}

    # library imports
    from faebryk.library.core import Component
    from faebryk.library.library.parameters import Constant
    from faebryk.library.library.interfaces import Electrical
    from faebryk.library.trait_impl.component import (
        has_defined_footprint,
        has_defined_footprint_pinmap,
        has_defined_type_description,
    )
    from faebryk.library.kicad import (
        has_defined_kicad_ref,
        KicadFootprint,
    )
    {library_imports}

    {definitions}

    {connections}

    comps = [
        {comps}
    ]

    t1_ = make_t1_netlist_from_graph(make_graph_from_components(comps))

    netlist = from_faebryk_t2_netlist(make_t2_netlist_from_t1(t1_))

    path = Path("./build/faebryk.net")
    logger.info("Writing Experiment netlist to {{}}".format(path.absolute()))
    path.write_text(netlist)

    from faebryk.exporters.netlist import render_graph

    render_graph(t1_)

# Boilerplate -----------------------------------------------------------------
import sys


def main(argc, argv, argi):
    logging.basicConfig(level=logging.INFO)

    logger.info("Running experiment")
    run_experiment()


if __name__ == "__main__":
    import os
    import sys

    root = os.path.join(os.path.dirname(__file__), "..")
    sys.path.append(root)
    main(len(sys.argv), sys.argv, iter(sys.argv))

"""

comp_template = """
    {ifs}

    {name} = Component()

    {unnamed_if_expr}
    {named_if_expr} 
    {trait_expr}
"""

unnamed_if_template = "{name}.IFs.add_all({unnamed_if_refs})"


def dict_to_str(obj):
    return "{" + "".join(f"{k}:{v}," for k, v in obj.items()) + "}"


def str_to_str(obj):
    return f'"{obj}"'


def from_t1_netlist(t1_netlist):
    # t1_netlist = [comps{
    #   name,
    #   real,
    #   properties,
    #   neighbors,
    #   value,
    # }]
    def sanitize_name(raw):
        sanitized = raw
        # braces
        sanitized = sanitized.replace("(", "")
        sanitized = sanitized.replace(")", "")
        sanitized = sanitized.replace("[", "")
        sanitized = sanitized.replace("]", "")
        # seperators
        sanitized = sanitized.replace(".", "_")
        sanitized = sanitized.replace(",", "_")
        sanitized = sanitized.replace("/", "_")
        # special symbols
        sanitized = sanitized.replace("'", "")
        sanitized = sanitized.replace("*", "")
        sanitized = sanitized.replace("^", "p")
        sanitized = sanitized.replace("#", "h")
        sanitized = sanitized.replace("ϕ", "phase")
        sanitized = sanitized.replace("π", "pi")
        sanitized = sanitized.replace("&", "and")
        # inversion
        sanitized = sanitized.replace("~", "n")
        sanitized = sanitized.replace("{", "")
        sanitized = sanitized.replace("}", "")

        sanitized = sanitized.replace("->", "to")
        sanitized = sanitized.replace("<-", "from")
        # arithmetics
        sanitized = sanitized.replace(">", "gt")
        sanitized = sanitized.replace("<", "lt")
        sanitized = sanitized.replace("=", "eq")
        sanitized = sanitized.replace("+", "plus")
        sanitized = sanitized.replace("-", "minus")

        # rest
        def handle_unknown_invalid_symbold(match):
            logger.warning(
                "Replacing unknown invalid symbol {} in {} with _".format(
                    match.group(0), raw
                )
            )
            return "_"

        sanitized = re.sub(r"[^a-zA-Z_0-9]", handle_unknown_invalid_symbold, sanitized)

        if re.match("^[a-zA-Z_]", sanitized) is None:
            sanitized = "_" + sanitized

        if re.match("^[a-zA-Z_]+[a-zA-Z_0-9]*$", sanitized) is not None:
            return sanitized

        to_escape = re.findall("[^a-zA-Z_0-9]", sanitized)
        if len(to_escape) > 0:
            return None, to_escape

        return sanitized

    components = t1_netlist
    project = template

    comp_names = {}
    if_names = {}

    def comp_to_faebryk(component):
        def get_comp_name(component):
            if component["name"].startswith("COMP["):
                class_name = re.search(r"\[(.*):.*\]", component["name"]).group(1)
            else:
                class_name = component["name"]

            class_name = sanitize_name(class_name)
            if re.match("^[a-zA-Z_]+[a-zA-Z_0-9]*$", class_name) is None:
                assert False, class_name

            ctr = comp_names.get(class_name, 0)
            name = "{type}_{ctr}".format(type=class_name, ctr=ctr)
            comp_names[class_name] = ctr + 1

            return name

        name = get_comp_name(component)

        pinmap = {pin: f"{name}.IFs.P{pin}" for pin in component["neighbors"].keys()}

        named_if_expr = "\n    ".join(
            [f"{pin_name} = Electrical()" for pin_name in pinmap.values()]
        )

        # Traits --------------------------------------------------
        trait_template = "\n    ".join(
            [
                f"{name}" + ".add_trait({trait_name}(",
                "    {trait_args}",
                "))",
            ]
        )

        traits = []
        def add_trait(name, args):
            traits.append(
                trait_template.format(trait_name=name, trait_args=args)
            )


        add_trait("has_defined_footprint_pinmap", dict_to_str(pinmap))

        if component["real"]:
            add_trait("has_defined_type_description", str_to_str(component["value"]))

            add_trait("has_defined_footprint",
                "KicadFootprint({})".format(str_to_str(component["properties"]["footprint"])),
            )

        trait_expr = "\n    ".join(traits)

        # ---------------------------------------------------------

        comp = comp_template.format(
            ifs="",
            unnamed_if_expr="",
            name=name,
            named_if_expr=named_if_expr,
            trait_expr=trait_expr,
        )

        return name, (comp, pinmap, component)

    named_comps = dict(map(comp_to_faebryk, components))
    name_map = {c["name"]: cname for cname, (_, __, c) in named_comps.items()}

    connections = {}
    for cname, (ccode, pinmap, comp) in sorted(named_comps.items(), key=lambda x: not x[1][2]["real"]):
        for pin, neighbors in comp["neighbors"].items():
            for neighbor in neighbors:
                neighborcname = name_map[neighbor["vertex"]["name"]]
                npin = neighbor["pin"]
                if ((neighborcname, npin), (cname, pin)) in connections:
                    # don't add connection if symmetric connection already exists
                    continue
                connections[((cname, pin), (neighborcname, npin))] = \
                    f"{pinmap[pin]}.connect({named_comps[neighborcname][1][npin]})"

    project = project.format(
        header="",
        docstring="",
        function_imports="",
        library_imports="",
        definitions="\n        ".join([c[0] for c in named_comps.values()]),
        connections="\n    ".join(connections.values()),
        comps=",\n        ".join(named_comps.keys()),
    )

    project = black.format_file_contents(project, fast=False, mode=black.Mode())
    # project = black.format_str(project, mode=black.Mode())

    return project
