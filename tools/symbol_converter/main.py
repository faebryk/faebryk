import hashlib
import logging
import pprint
import sys

import click

from faebryk.libs.pycodegen import sanitize_name
from faebryk.libs.util import groupby

logging.basicConfig(stream=sys.stderr, level=logging.INFO)
logger = logging.getLogger("sym_gen")
logger.setLevel(logging.DEBUG)


def sanitize_pin_name(name: str, no: str):
    if name == "~":
        if no.isnumeric():
            name = "unnamed"
        else:
            name = no

    return sanitize_name(name)


def generate_component(symbol, annotation_properties, keep_source):
    annotation = "\n    ".join(
        [f"{key}: {val}" for key, val in annotation_properties.items()]
    )
    raw_name = symbol["name"]
    name = sanitize_name(raw_name)
    if type(name) is tuple and name[0] is None:  # TODO use exception
        logger.error(f"Unescapable symbol name in {raw_name}: [{name[1]}]")

    parent = "Component"
    if "extends" in symbol:
        raw_parent = symbol["extends"]
        parent = sanitize_name(raw_parent)

    # interfaces
    raw_pins = {
        no: pin
        for symbol_2 in symbol.get("symbols", {}).values()
        for no, pin in symbol_2.get("pins", {}).items()
    }

    for no, pin in raw_pins.items():
        pname = sanitize_pin_name(pin["name"], no)
        if type(pname) is tuple and pname[0] is None:  # TODO use exception
            logger.error(
                f"Unescapable pin name in pin {pin['name']}: [{pname[1]}] in symbol {name}"
            )
            return f"#Skipped invalid component {name}"
        pin["sanitized"] = pname

    # not hidden pins
    # pins = {no: pin for no, pin in raw_pins.items() if not pin["hide"]}

    faebryk_if_map = {}
    pins_grouped_by_names = groupby(raw_pins.items(), key=lambda x: x[1]["sanitized"])

    for pname, group in pins_grouped_by_names.items():
        for i, (no, pin) in enumerate(group):
            faebryk_if_map[no] = pname
            if len(group) > 1:
                faebryk_if_map[no] += f"[{i}]"

    ifs_exp = ("\n" + "    " * 3).join(
        [
            f"{pname} = "
            + (f"times({len(group)}, Electrical)" if len(group) > 1 else "Electrical()")
            for pname, group in pins_grouped_by_names.items()
        ]
    )

    pinmap = dict(faebryk_if_map)

    # raw
    if keep_source:
        raw_symbol = pprint.pformat(symbol["_raw"], indent=4, width=88).replace(
            "\n", "\n        "
        )
    else:
        raw_symbol = "omitted"

    #
    class_traits = []
    instance_traits = []

    # footprint & footprint pinmap
    footprint_str = symbol["properties"]["Footprint"].replace('"', "")
    if footprint_str != "":
        footprint_trait = 'has_defined_footprint(KicadFootprint("{}"))'.format(
            footprint_str
        )
        class_traits.append(footprint_trait)
        pinmap_trait = "has_defined_footprint_pinmap({})".format(
            "{"
            + ", ".join([f'"{pinno}": self.IFs.{_if}' for pinno, _if in pinmap.items()])
            + "}"
        )
        instance_traits.append(pinmap_trait)

    #
    class_traits.append(
        'has_defined_kicad_ref("{}")'.format(symbol["properties"]["Reference"])
    )
    class_traits.append(f'has_defined_type_description("{raw_name}")')

    class_traits_exp = "\n        ".join(
        [f"self.add_trait({trait})" for trait in class_traits]
    )
    instance_traits_exp = "\n        ".join(
        [f"self.add_trait({trait})" for trait in instance_traits]
    )

    template = "\n".join(
        filter(
            lambda x: x is not None,
            [
                f"class {name}({parent}):",
                f'    """',
                f"    Generated by symbol_converter",
                f"    {annotation}",
                f"    source:",
                f"        {raw_symbol}",
                f'    """',
                f"",
                f"    def _setup_traits(self):",
                f"        super()._setup_traits()" if parent != "Component" else None,
                f"        {class_traits_exp}" if class_traits_exp != "" else None,
                f"        return",
                f"",
                f"    def _setup_interfaces(self):",
                f"        super()._setup_interfaces()"
                if parent != "Component"
                else None,
                *(
                    [
                        f"        class _IFs(Component.InterfacesCls()):",
                        f"            {ifs_exp}" if ifs_exp != "" else None,
                        f"",
                        f"        self.IFs = _IFs(self)",
                    ]
                    if ifs_exp != ""
                    else []
                ),
                f"        return",
                f"",
                *(
                    [
                        f"    def __new__(cls, *args, **kwargs):",
                        f"        self = super().__new__(cls)",
                        f"        self._setup_traits()",
                        f"        return self",
                        f"",
                    ]
                    if parent == "Component"
                    else []
                ),
                f"    def __init__(self):",
                f"        super().__init__()",
                f"        self._setup_interfaces()" if parent == "Component" else None,
                f"        {instance_traits_exp}" if instance_traits_exp != "" else None,
                f"        return",
            ],
        )  # type: ignore
    )
    return template


@click.command()
@click.option(
    "--keep-source",
    default=False,
    help="Insert netlist source into class as comment.",
    is_flag=True,
)
@click.argument("sourcefile", type=click.File("r"))
@click.argument("destfile", type=click.File("w"))
def main(sourcefile, destfile, keep_source):
    """
    Generates faebryk components from kicad symbols

    SOURCEPATH: Path to kicad symbol library file (.sym)

    DESTPATH: Path to generated file (.py)
    """
    from faebryk.libs.kicad.parser import parse_kicad_symbol_lib

    logger.info("Parsing & Converting %s -> %s", sourcefile.name, destfile.name)

    raw_sexp = "".join(sourcefile.readlines())
    sourcefile.close()

    file_hash = hashlib.sha1(raw_sexp.encode("utf-8")).hexdigest()

    lib = parse_kicad_symbol_lib(raw_sexp)
    logger.info("Found {} symbols".format(len(lib["symbols"])))

    components = [
        generate_component(
            symbol,
            {
                "filepath": sourcefile.name,
                "hash": file_hash,
            },
            keep_source,
        )
        + "\n"
        for symbol in lib["symbols"].values()
    ]

    output = "\n".join(
        [
            '"""',
            "   Generated by symbol_converter",
            '"""',
            "",
            "from faebryk.library.core import Component",
            "from faebryk.library.library.interfaces import Electrical",
            "from faebryk.library.util import times",
            "from faebryk.library.trait_impl.component import has_defined_footprint_pinmap, has_defined_footprint, has_defined_type_description",
            "from faebryk.library.kicad import has_defined_kicad_ref, KicadFootprint",
        ]
        + components
    )
    # output = black.format_file_contents(output, fast=True, mode=black.Mode())

    destfile.write(output)


if __name__ == "__main__":
    main()
